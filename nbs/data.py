# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/16data_generation.ipynb.

# %% auto 0
__all__ = ['folder', 'mapbox_access_token', 'split_csv_file', 'combine_csv_files', 'generate_cust', 'enumerate_near_points',
           'plot_cust', 'generate_prod', 'generate_many_prod', 'generate_demand', 'generate_demand_normal',
           'generate_demand_with_promo', 'generate_reservation_demand', 'demand_attribute_compute', 'generate_dc',
           'generate_plnt']

# %% ../nbs/16data_generation.ipynb 3
import glob
import colorlover as cl
import pickle
import numpy as np
#import dash_table
import plotly.graph_objs as go
import plotly.express as px
import plotly
from .mypulp import GRB, quicksum, Model
#from gurobipy import GRB, quicksum, Model
import pandas as pd
import random
import string
import datetime
import math
from collections import OrderedDict, defaultdict
import networkx as nx
from IPython.display import Image
#import seaborn as sns
from faker import Faker
from scipy.spatial import KDTree
from scipy.spatial import distance
from geopy.distance import great_circle 
folder = "./data/"
mapbox_access_token = 'pk.eyJ1IjoibWlraW9rdWJvIiwiYSI6ImNqYXQ3dHBqdzR5ZGwyd3BkeG5rOTl0b2UifQ.1utsXNi2V-WdzfWlvCMj_A'

# %% ../nbs/16data_generation.ipynb 28
#郵便番号データは分けて保管する（ファイルが大きすぎるため）
def split_csv_file(input_file, output_prefix, chunk_size):
    # CSVファイルを読み込む
    reader = pd.read_csv(input_file, chunksize=chunk_size)
    # 分割したCSVファイルを保存するカウンター
    file_count = 1
    # 分割したCSVファイルを処理するループ
    for chunk in reader:
        # 分割されたCSVファイルの名前を作成
        output_file = f"{output_prefix}_{file_count}.csv"
        # 分割されたCSVファイルを保存
        chunk.to_csv(output_file, index=False)
        # ファイルカウンターをインクリメント
        file_count += 1

# 入力CSVファイルのパス
# input_file = folder+"zipcode_no_island.csv"

# # 分割したCSVファイルの出力先とファイル名のプレフィックス
# output_prefix = folder+"output_chunk"

# # 1つのファイルに含める行数
# chunk_size = 10000

# # CSVファイルを分割して保存
# split_csv_file(input_file, output_prefix, chunk_size)

# %% ../nbs/16data_generation.ipynb 29
#読み込み
def combine_csv_files(input_prefix):
    # ファイル名パターンに基づいて分割されたCSVファイルのリストを取得
    file_list = glob.glob(input_prefix + "*.csv")
    
    # 分割されたCSVファイルを読み込んで結合
    combined_df = pd.concat([pd.read_csv(file) for file in file_list], ignore_index=True)

    return combined_df 
    # 結合したデータフレームをCSVファイルとして保存
    #combined_df.to_csv(output_file, index=False)

# # 分割されたCSVファイルのプレフィックスと出力ファイル名
# input_prefix = folder+"output_chunk_"

# # 分割されたCSVファイルを結合して元のデータフレームを再構築
# df = combine_csv_files(input_prefix)

# %% ../nbs/16data_generation.ipynb 30
def generate_cust(num_locations=10, random_seed=1, prefecture=None):
    """
    顧客データをランダムに生成する関数
    """
    # if no_island:
    #     df = pd.read_csv(folder+"zipcode_no_island.csv") 
    # else:
    #     df = pd.read_csv(folder+"zipcode.csv") 
    input_prefix = folder+"output_chunk_"
    df = combine_csv_files(input_prefix)
    if prefecture == None:
        if num_locations > len(df):
            print("number of customers is too large! It exceeds the number of zip points in Japan!")
            return -1
        else:
            cust_df = df.sample(n=num_locations, random_state=random_seed)
    else:
        cust_df = df[df.name1 == prefecture]
        if num_locations > len(cust_df):
            print("number of customers is too large! Change the prefecture or set to None!")
            return -1
        else:
            cust_df = cust_df.sample(n=num_locations, random_state=random_seed)

    cust_df.reset_index(inplace=True)
    cust_df.drop("index", axis=1, inplace=True)
    # cust_df.columns
    cust_df.rename(columns={"name1": "都道府県", "name2": "市区町村", "name3": "大字",
                            "latitude": "lat", "longitude": "lon"}, inplace=True)

    Faker.seed(random_seed)
    fake = Faker(['ja_JP'])
    fake_name = []
    fake_name_set = set([])
    for _ in range(len(cust_df)):
        while 1:
            temp = fake.company() + f" 第 {random.randint(1,100)} 支店" 
            if temp not in fake_name_set:
                fake_name.append(temp)
                fake_name_set.add(temp)
                break
            
    cust_df["name"] = fake_name
    
    cust_df = cust_df.astype({"lat":float,"lon":float}) #型変換
    return cust_df

# %% ../nbs/16data_generation.ipynb 34
def enumerate_near_points(cust_df, max_dis:float):
    """
    地点間の距離が小さい顧客同士を列挙する関数 enumerate_near_points
    """
    points = [(i,j)  for (i,j)  in zip(cust_df.lat, cust_df.lon)]
    tree = KDTree(points)
    res = tree.query_pairs(max_dis)
    #print('same coordinate pairs=', len(res) )
    point1, point2, euc_dis, gc_dis =[],[],[],[]
    for (i,j) in res:
        #print(distance.euclidean(points[i], points[j]), great_circle(points[i], points[j]))
        point1.append(cust_df.iloc[i,-1])
        point2.append(cust_df.iloc[j,-1])
        euc_dis.append(distance.euclidean(points[i], points[j]))
        gc_dis.append(great_circle(points[i], points[j]))
        
    return pd.DataFrame({"point1": point1, "point2":point2, "Euclidean distance":euc_dis, "Great circle distance": gc_dis})

# %% ../nbs/16data_generation.ipynb 45
def plot_cust(cust_df, weight=None):
    """
    顧客データフレームを入れると、PlotlyのFigureオブジェクトに地図を入れて返す関数
    """
    if weight is None:
        weight = 10.
    else:
        max_weight = weight.max()
        weight = 10. + weight/(max_weight+1.)*30.
        
    data = [
        go.Scattermapbox(
            lat=cust_df.lat,
            lon=cust_df.lon,
            mode='markers',
            marker=dict(
                size=weight, color="red", opacity=0.9
            ),
            text= cust_df["name"],
            name="Customers"
        ),
    ]

    layout = go.Layout(
        autosize=True,
        hovermode='closest',
        mapbox=dict(
            accesstoken=mapbox_access_token,
            bearing=0,
            center=dict(
                lat= cust_df.lat.iloc[0],   #35.8573157,
                lon= cust_df.lon.iloc[0]   #139.64696
            ),
            pitch=0,
            zoom=5,
            style='satellite-streets'
        ),
        width=800, height=800
    )

    fig = go.Figure(data=data, layout=layout)
    return fig

# %% ../nbs/16data_generation.ipynb 50
def generate_prod(num_prod=10, weight_bound=(0, 0), volume_bound=(0, 0), cust_value_bound=(1, 1),
                  dc_value_bound=(1, 1), plnt_value_bound=(1, 1), fc_bound=(1, 1), random_seed =1):
    """
    仮想の製品のデータフレームを生成する関数
    """
    random.seed(random_seed)
    alphabet = string.ascii_uppercase
    assert num_prod<=len(alphabet)
    prod_index = list(alphabet[:num_prod])
    prod_df = pd.DataFrame(data={"name": prod_index,
                                 "weight": [random.randint(weight_bound[0], weight_bound[1]) for i in range(num_prod)],
                                 "volume": [random.randint(volume_bound[0], volume_bound[1]) for i in range(num_prod)],
                                 "cust_value": [random.randint(cust_value_bound[0], cust_value_bound[1]) for i in range(num_prod)],
                                 "dc_value": [random.randint(dc_value_bound[0], dc_value_bound[1]) for i in range(num_prod)],
                                 "plnt_value": [random.randint(plnt_value_bound[0], plnt_value_bound[1]) for i in range(num_prod)],
                                 "fixed_cost": [random.randint(fc_bound[0], fc_bound[1]) for i in range(num_prod)]
                                 })
    return prod_df

# %% ../nbs/16data_generation.ipynb 51
def generate_many_prod(num_prod=100, weight_bound=(0, 0), volume_bound=(0, 0), cust_value_bound=(1, 1),
                  dc_value_bound=(1, 1), plnt_value_bound=(1, 1), fc_bound=(1, 1), random_seed =1):
    """
    仮想の製品のデータフレーム（２６より大きい）を生成する関数
    """
    random.seed(random_seed)
    prod_index = [ f"prod{p}" for p in range(num_prod)]
    prod_df = pd.DataFrame(data={"name": prod_index,
                                 "weight": [random.randint(weight_bound[0], weight_bound[1]) for i in range(num_prod)],
                                 "volume": [random.randint(volume_bound[0], volume_bound[1]) for i in range(num_prod)],
                                 "cust_value": [random.randint(cust_value_bound[0], cust_value_bound[1]) for i in range(num_prod)],
                                 "dc_value": [random.randint(dc_value_bound[0], dc_value_bound[1]) for i in range(num_prod)],
                                 "plnt_value": [random.randint(plnt_value_bound[0], plnt_value_bound[1]) for i in range(num_prod)],
                                 "fixed_cost": [random.randint(fc_bound[0], fc_bound[1]) for i in range(num_prod)]
                                 })
    return prod_df

# %% ../nbs/16data_generation.ipynb 56
def generate_demand(cust_df, prod_df, cust_shape=1.7, prod_shape=1.7,
                    weekly_ratio=[1]*7, yearly_ratio=[1]*12, start="2019/01/01", periods=365, 
                    epsilon=0., correlation = 0.8, random_seed = 1):
    """
    ランダムな需要を生成する関数
    """
    np.random.seed(random_seed)
    random.seed(random_seed)
    cust_col, prod_col, demand_col = [], [], []
    date_col = []
    # パレート分布を用いて基本需要を生成
    cust_basic = np.random.pareto(cust_shape, len(cust_df))
    prod_basic = np.random.pareto(prod_shape, len(prod_df))

    yearly_ratio = [0] + yearly_ratio  # 1月から開始するためダミーの0月を追加
  
    # 共分散行列
    num_prods = len(prod_df)
    cov_matrix = np.ones(shape=(num_prods,num_prods))*(epsilon**2)
    for i in range(num_prods-1):
        for j in range(i,num_prods):
            if i!=j:
                cov_matrix[i,j] *= correlation 
                cov_matrix[j,i] = cov_matrix[i,j]
    #製品ごとの誤差項
    error = np.random.multivariate_normal(np.zeros(shape=(num_prods,)), cov_matrix)

    for t in pd.date_range(start, periods=periods):
        for i, c in enumerate(cust_df.name):
            for j, p in enumerate(prod_df.name):
                date_col.append(t)
                cust_col.append(c)
                prod_col.append(p)
                rand_dem = max(int(cust_basic[i]*prod_basic[j]*weekly_ratio[t.weekday()]*yearly_ratio[t.month]
                                   + error[j]), 0)
                demand_col.append(rand_dem)

    demand_df = pd.DataFrame(
        data={"date": date_col, "cust": cust_col, "prod": prod_col, "demand": demand_col})
    return demand_df

# %% ../nbs/16data_generation.ipynb 59
def generate_demand_normal(cust_df, prod_df, cust_loc, cust_scale, prod_loc, prod_scale, 
                    weekly_ratio=[1]*7, yearly_ratio=[1]*12, start="2019/01/01", periods=365, epsilon=0., random_seed = 1):
    """
    ランダムな正規分布の需要を生成する関数
    """
    np.random.seed(random_seed)
    random.seed(random_seed)
    cust_col, prod_col, demand_col = [], [], []
    date_col = []
    # 基本需要を生成
    cust_basic = np.random.normal(cust_loc, cust_scale, len(cust_df))
    prod_basic = np.random.normal(prod_loc, prod_scale, len(prod_df))

    yearly_ratio = [0] + yearly_ratio  # 1月から開始するためダミーの0月を追加

    for t in pd.date_range(start, periods=periods):
        for i, c in enumerate(cust_df.name):
            for j, p in enumerate(prod_df.name):
                date_col.append(t)
                cust_col.append(c)
                prod_col.append(p)
                rand_dem = max(int(cust_basic[i]*prod_basic[j]*weekly_ratio[t.weekday()]*yearly_ratio[t.month]
                                   + random.gauss(0, epsilon)), 0)
                demand_col.append(rand_dem)

    demand_df = pd.DataFrame(
        data={"date": date_col, "cust": cust_col, "prod": prod_col, "demand": demand_col})
    return demand_df

# %% ../nbs/16data_generation.ipynb 63
def generate_demand_with_promo(cust_df, prod_df, promo_df, cust_shape=1.7, prod_shape=1.7,
                    weekly_ratio=[1]*7, yearly_ratio=[1]*12, start="2019/01/01", periods=365, epsilon=0. ,
                              promo_0_ratio=1.5, promo_1_ratio=2.0, correlation = 0.8, random_seed = 1):
    """
    プロモーション情報を加味したランダムな需要を生成する関数
    """
    np.random.seed(random_seed)
    random.seed(random_seed)

    promo_df.set_index("date", inplace=True)

    cust_col, prod_col, demand_col = [], [], []
    date_col = []
    # パレート分布を用いて基本需要を生成
    cust_basic = 1. + np.random.pareto(cust_shape, len(cust_df))
    prod_basic = 1. + np.random.pareto(prod_shape, len(prod_df))

    #顧客と製品の基本値に乗じるプロモーションの効果（promo_0は顧客に、promo_1は製品に対してかかるものとする。）
    cust_promo = np.random.uniform(1.0, promo_0_ratio, len(cust_df))
    prod_promo = np.random.uniform(1.0, promo_1_ratio, len(prod_df))

    yearly_ratio = [0] + yearly_ratio  # 1月から開始するためダミーの0月を追加

    #製品間の相関を加味
    # 共分散行列
    num_prods = len(prod_df)
    cov_matrix = np.ones(shape=(num_prods,num_prods))*(epsilon**2)
    for i in range(num_prods-1):
        for j in range(i,num_prods):
            if i!=j:
                cov_matrix[i,j] *= correlation 
                cov_matrix[j,i] = cov_matrix[i,j]
    #製品ごとの誤差項
    error = np.random.multivariate_normal(np.zeros(shape=(num_prods,)), cov_matrix)
    
    promo0_col, promo1_col = [], []
    for idx, t in enumerate(pd.date_range(start, periods=periods)):
        for i, c in enumerate(cust_df.name):
            for j, p in enumerate(prod_df.name):
                date_col.append(t)
                cust_col.append(c)
                prod_col.append(p)
                promo_0 = promo_df.iloc[idx,0]
                promo_1 = promo_df.iloc[idx,1]
                if promo_0:
                    rand_dem = max(int(cust_promo[i]*cust_basic[i]*prod_basic[j]*weekly_ratio[t.weekday()]*yearly_ratio[t.month]
                                   + error[j]), 0)
                elif promo_1:
                    rand_dem = max(int(prod_promo[j]*cust_basic[i]*prod_basic[j]*weekly_ratio[t.weekday()]*yearly_ratio[t.month]
                                   + error[j]), 0)
                else:
                    rand_dem = max(int(cust_basic[i]*prod_basic[j]*weekly_ratio[t.weekday()]*yearly_ratio[t.month]
                                   + error[j]), 0)
                demand_col.append(rand_dem)
                promo0_col.append(promo_0)
                promo1_col.append(promo_1)

    demand_df = pd.DataFrame(
        data={"date": date_col, "cust": cust_col, "prod": prod_col,
              "promo_0":promo0_col, "promo_1":promo1_col, "demand": demand_col})
    return demand_df, cust_promo, prod_promo

# %% ../nbs/16data_generation.ipynb 69
def generate_reservation_demand(class_df, weekly_ratio=[1]*7, start="2019/01/01", periods=7, max_lt = 1):
    """
    ランダムな予約需要を生成する関数
    """
    reserve_col, checkin_col, class_col, demand_col = [], [], [], []

    # Poisson分布を用いて需要を生成
    for checkin_t in pd.date_range(pd.to_datetime(start) + datetime.timedelta(max_lt), periods=periods-max_lt):
        for reserve_t in pd.date_range(checkin_t-datetime.timedelta(max_lt), periods=max_lt+1): # allow the same day reservation
            for i, c in enumerate(class_df.class_name):
                checkin_col.append(checkin_t)
                reserve_col.append(reserve_t)
                class_col.append(c)
                rand_dem = max(np.random.poisson(class_df.basic_demand[i]*weekly_ratio[reserve_t.weekday()],1)[0] , 0)
                demand_col.append(rand_dem)

    reserve_demand_df = pd.DataFrame(
        data={"reserve": reserve_col, "checkin": checkin_col, "class_name": class_col, "demand": demand_col})
    return reserve_demand_df

# %% ../nbs/16data_generation.ipynb 84
def demand_attribute_compute(demand_df, prod_df, attribute_col_name, new_col_name):
    """
    需要データに新たな属性を追加する関数
    """
    assert attribute_col_name in prod_df.columns
    col_list = prod_df[attribute_col_name]
    dic ={}
    for i, name in enumerate(prod_df.name):
        dic[name] = col_list[i]
    new_col_list =[]
    for row in demand_df.itertuples():
        new_col_list.append( row.demand * dic[row.prod] )
    demand_df[new_col_name] = new_col_list
    return demand_df

# %% ../nbs/16data_generation.ipynb 88
def generate_dc(cust_df, demand_df, prod_df, num_dc=5, lb_ratio=0.8, ub_ratio=1.2, vc_bounds=(0.0, 0.5), fc_bounds=(10000,11000), random_seed=1):
    """
    倉庫データの生成：
    顧客データ、需要データ、製品データ、予定開設数、倉庫の容量を決めるための下限率、上限率を与えると、倉庫データを返す。
    """
    assert num_dc > 0
    assert lb_ratio < ub_ratio
    np.random.seed(random_seed)
    
    total_demand = pd.pivot_table(
        demand_df, index="prod", values="demand", aggfunc=sum)
    #total_demand.head()

    #total_weight = (total_demand.demand.values * prod_df.weight.values[:len(total_demand.demand.values)]).sum()
    total_weight = total_demand.demand.values.sum()
    average_capacity = total_weight/num_dc
    fixed_cost = np.random.randint( fc_bounds[0],fc_bounds[1], len(cust_df) ) 
    variable_cost = np.random.uniform( vc_bounds[0], vc_bounds[1], len(cust_df) )
    dc_df = pd.DataFrame(data={"name": cust_df.name.tolist(), "lb": average_capacity*lb_ratio, "ub": average_capacity*ub_ratio, "fc": fixed_cost, "vc": variable_cost,
                               "lat": cust_df.lat.tolist(), "lon": cust_df.lon.tolist()})
    return dc_df

# %% ../nbs/16data_generation.ipynb 92
def generate_plnt(prod_df, demand_df, lead_time_bound= (1,2), random_seed = 1):
    """
    工場データの生成
    """
    np.random.seed(random_seed)
    
    plnt_list=["Odawara","Osaka","Chiba"]
    plnt_lat =[35.2849816, 34.5631009, 35.5434516]
    plnt_lon =[139.1961334, 135.4151286, 140.1139081]
    plnt_df = pd.DataFrame(data={"name":plnt_list,  "lat":plnt_lat, "lon":plnt_lon} )

    products = list(set(demand_df["prod"]))
    num_prod = len(products)

    num_prod_osaka = num_prod//2
    num_prod_chiba = num_prod - num_prod_osaka
    plnt_col = ["Osaka"]*num_prod_osaka + ["Chiba"] * num_prod_chiba + ["Odawara"]*num_prod
    prod_col = products[:num_prod_osaka] + products[num_prod_osaka:num_prod] + products[:num_prod]
    ub_col = []
    lt_col = []
    dem = pd.pivot_table(demand_df, index="prod", values="demand", aggfunc=sum)
    for p in prod_col:
        ub_col.append( dem.loc[p].demand)
        lt_col.append( np.random.randint(lead_time_bound[0],lead_time_bound[1]))
    plnt_prod_df = pd.DataFrame(
        data={"plnt": plnt_col,  "prod": prod_col, "ub": ub_col, "lead_time": lt_col})

    return plnt_df, plnt_prod_df
